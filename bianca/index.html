<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="author" content="Bianca Denisa Diaconu">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <link rel="stylesheet" href="./style.css">
    <title>Liste Dublu Inlantuite</title>
</head>

<body>
    <header class="v-header" id="target">
        <div class="fullscreen-wrap">
            <img src="./assets/bg.jpg">
        </div>
        <div class="header-content">
            <h2>Liste Simplu Înlanțuite</h2>
        </div>
    </header>
    <div class="container">
        <h1>Liste Simplu Înlanțuite</h1>
        <h5>Software realizat de Bianca Denisa Diaconu</h5>
        <p>
            O lista dublu inlanțuită este o structură de date constituită dintr-o succesiune de elemente denumite
            noduri. Fiecare nod din listă conține 3 părți: o parte de informație (în care sunt memorate informațiile
            corespunzătoare nodului, specifice problemei) și două părți de legatura (în care este memorată adresa
            următorului element din listă și respectiv adresa precedentului element din listă).
        </p>
        <div class="card">
            <div class="card-header">
                <h2>Declarația listei dublu înlanțuite</h2>
            </div>
            <div class="card-body">
                <p>
                    Declarația structurii care reprezintă un nod dintr-o listă dublu înlănțuită cu informații întregi va
                    fi:
                </p>
                <pre>
                    <code class="cpp">
                        struct nod
                        {
                            int inf;
                            struct nod *urm, *pre;
                        };
                        typedef struct nod *lista;
                    </code>
                </pre>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h2><i>Exemplu</i></h2>
            </div>
            <div class="card-body">
                <p>Putem figura o listă dublu înlănțuită cu elemente întregi astfel:</p>
                <img src="./assets/liste.jpg" alt="liste" class="img-fluid">
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h2>Inserare unui nod intr-o listă dublu înlănțuită</h2>
            </div>
            <div class="card-body">
                <p>Pentru inserare vom implementa o funcție denumită <strong>Inserare</strong> cu 3 parametrii:</p>
                <ol>
                    <li>
                        <strong>prim</strong> - pointer care conține adresa primului nod din lista în care se face
                        inserarea; acest parametru va fi transmis prin referință deoarece în urma inserării începutul
                        listei se poate modifica.
                    </li>
                    <li>
                        <strong>p</strong> - pointer care conține adresa nodului din listă după care se face inserarea;
                        dacă <strong>p</strong> este <strong>NULL</strong> deducem ca inserarea noului nod se va face la
                        începutul liste
                    </li>
                    <li>
                        <strong>x</strong> - informația nodului care urmează sa fie inserat in listă.
                    </li>
                </ol>
                <p>
                    Vom aloca dinamic memorie pentru un nou nod, a cărui adresă o vom reține în variabila pointer
                    <strong>q</strong>. În zona de informații vom memora valoarea <strong>x (q -> inf) = x</strong>.
                    <br>
                    La inserare apar două cazuri distincte:
                </p>
                <ul>
                    <li>
                        Dacă <strong>p != NULL</strong> inserarea se face în interiorul listei
                    </li>
                    <li>
                        Dacă <strong>p == NULL</strong> noul nod va fi inserat la începutul listei
                    </li>
                </ul>
                <h3><i>Exemplu</i></h3>
                <p>
                    Să ilustrăm pas cu pas inserarea la începutul listei din exemplul precedent a unui nod, cu
                    informația 3, nod al carui adresă va fi memorat in pointerul q:
                </p>
                <ol>
                    <li>
                        Creăm o legătura de la noul nod către primul nod din listă, memorand in campul
                        <strong>urm</strong> al noului nod adresa primului nod din listă (q -> urm = prim). Noul nod va
                        fi primul nod din listă, deci nu are precedent (q -> pre = NULL)
                    </li>
                    <img src="./assets/inserare.jpg" alt="inserare" class="img-fluid">
                    <li>
                        Precedentul primului nod din listă va fi q (prim -> pre = q), iar primul nod din listă este de
                        acum noul nod (prim = q).
                    </li>
                    <img src="./assets/inserare2.jpg" alt="inserare 2" class="img-fluid">
                </ol>
                <p>
                    În cel de-al doilea caz trebuie sa inserăm noul nod după nodul a cărui adresă este memorată in
                    parametrul p.
                </p>
                <h3><i>Exemplu</i></h3>
                <p>
                    Să ilustrăm pas cu pas inserarea in lista din exemplul precedent a unui nod cu informația 3, după
                    nodul cu informația 7
                </p>
                <ol>
                    <li>
                        Creăm legăturile dintre noul nod și precedentul său în listă (q -> prev = p), respectiv
                        succesorul său in listă - nodul indicat de p -> urm (q -> urm = p -> urm):
                    </li>
                    <img src="./assets/inserare3.jpg" alt="inserare 3" class="img-fluid">
                    <li>
                        Modificăm legăturile dintre nodurile din listă: dupa nodul indicat de p va urma noul nod (p ->
                        urm = q), iar înaintae nodului care urma după cel indicat de p (dacă acesta există) va fi noul
                        nod (q -> urm -> pre = q)
                    </li>
                    <img src="./assets/inserare4.jpg" alt="inserare 4" class="img-fluid">
                </ol>
                <pre>
                    <code class="cpp">
                            void insert(lista &prim, lista p, int x)
                                {
                                    lista q = new nod;
                                    q -< inf = x;
                                    p -> pre = p;
                                    if(!p) //inserarea la inceputul listei
                                    {
                                        if (prim) prim -> pre = q;
                                        prim = q;
                                    }
                                }
                    </code>
                </pre>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h2>Ștergerea unui nod dintr-o listă dublu înlănțuită</h2>
            </div>
            <div class="card-body">
                <p>Pentru ștergere vom implementa o funcție numită <strong>delete</strong> cu 2 parametrii:</p>
                <ol>
                    <li>
                        <strong>prim</strong> - pointer care conține adresa primului nod al listei din care se face
                        ștergerea; acest parametru va fi transmis prin referință, deoarece în urma ștergerii,
                        începutul listei se poate modifica.
                    </li>
                    <li>
                        <strong>q</strong> - pointer care conține adresa nodului din listă ce urmează a fi șters.
                    </li>
                </ol>
                <p>
                    Pentru simplitate, vom utiliza 2 pointeri suplimentari, <strong>p</strong> care reține adresa
                    nodului ce preceda nodul de șters și <strong>r</strong>
                    care reține adresa nodului ce succedă nodul de șters. Dacă p == NULL va fi șters primul nod din
                    listă și va trebui să actualizăm valoarea parametrului <strong>prim</strong>.
                </p>
                <pre>
                    <code class="cpp">
                                void delete(lista & prim, lista q)
                                {
                                    lista p = q -> pre,
                                    r = q -> urm;
                                    if (p) p -> urm = r;
                                        else prim = r;
                                    if (r) r -> pre = p;
                                    delete q;
                                }
                    </code>
                </pre>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h2>
                    Consultarea unei liste dublu înlănțuite
                </h2>
            </div>
            <div class="card-body">
                <p>
                    Consultarea unei liste dublu înlănțuite se realizează in mod similar cu cea a unei liste simplu
                    înlănțuite, numai că o listă dublu înlănțuită poate fi consultată atât in sens direct (utilizând
                    legaturile urm), cât și în sens invers (utilizând legaturile pre).
                </p>
            </div>
        </div>
        <a href="#target" role="button" class="btn btn-primary btn-lg btn-block">
            Back
        </a>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script>
</body>

</html>